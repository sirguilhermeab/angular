{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Guilherme/Downloads/ModuleFederation/mfe-shell/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nlet config = {};\nconst containerMap = {};\nconst remoteMap = {};\nlet isDefaultScopeInitialized = false;\nfunction lookupExposedModule(_x, _x2) {\n  return _lookupExposedModule.apply(this, arguments);\n}\nfunction _lookupExposedModule() {\n  _lookupExposedModule = _asyncToGenerator(function* (key, exposedModule) {\n    const container = containerMap[key];\n    const factory = yield container.get(exposedModule);\n    const Module = factory();\n    return Module;\n  });\n  return _lookupExposedModule.apply(this, arguments);\n}\nfunction initRemote(_x3, _x4) {\n  return _initRemote.apply(this, arguments);\n}\nfunction _initRemote() {\n  _initRemote = _asyncToGenerator(function* (container, key) {\n    // const container = window[key] as Container;\n    // Do we still need to initialize the remote?\n    if (remoteMap[key]) {\n      return container;\n    }\n    // Do we still need to initialize the share scope?\n    if (!isDefaultScopeInitialized) {\n      yield __webpack_init_sharing__('default');\n      isDefaultScopeInitialized = true;\n    }\n    yield container.init(__webpack_share_scopes__.default);\n    remoteMap[key] = true;\n    return container;\n  });\n  return _initRemote.apply(this, arguments);\n}\nfunction loadRemoteEntry(_x5, _x6) {\n  return _loadRemoteEntry.apply(this, arguments);\n}\nfunction _loadRemoteEntry() {\n  _loadRemoteEntry = _asyncToGenerator(function* (remoteEntryOrOptions, remoteName) {\n    if (typeof remoteEntryOrOptions === 'string') {\n      const remoteEntry = remoteEntryOrOptions;\n      return yield loadRemoteScriptEntry(remoteEntry, remoteName);\n    } else if (remoteEntryOrOptions.type === 'script') {\n      const options = remoteEntryOrOptions;\n      return yield loadRemoteScriptEntry(options.remoteEntry, options.remoteName);\n    } else if (remoteEntryOrOptions.type === 'module') {\n      const options = remoteEntryOrOptions;\n      yield loadRemoteModuleEntry(options.remoteEntry);\n    }\n  });\n  return _loadRemoteEntry.apply(this, arguments);\n}\nfunction loadRemoteModuleEntry(_x7) {\n  return _loadRemoteModuleEntry.apply(this, arguments);\n}\nfunction _loadRemoteModuleEntry() {\n  _loadRemoteModuleEntry = _asyncToGenerator(function* (remoteEntry) {\n    if (containerMap[remoteEntry]) {\n      return Promise.resolve();\n    }\n    return yield import( /* webpackIgnore:true */remoteEntry).then(container => {\n      initRemote(container, remoteEntry);\n      containerMap[remoteEntry] = container;\n    });\n  });\n  return _loadRemoteModuleEntry.apply(this, arguments);\n}\nfunction loadRemoteScriptEntry(_x8, _x9) {\n  return _loadRemoteScriptEntry.apply(this, arguments);\n}\nfunction _loadRemoteScriptEntry() {\n  _loadRemoteScriptEntry = _asyncToGenerator(function* (remoteEntry, remoteName) {\n    return new Promise((resolve, reject) => {\n      // Is remoteEntry already loaded?\n      if (containerMap[remoteName]) {\n        resolve();\n        return;\n      }\n      const script = document.createElement('script');\n      script.src = remoteEntry;\n      script.onerror = reject;\n      script.onload = () => {\n        const container = window[remoteName];\n        initRemote(container, remoteName);\n        containerMap[remoteName] = container;\n        resolve();\n      };\n      document.body.appendChild(script);\n    });\n  });\n  return _loadRemoteScriptEntry.apply(this, arguments);\n}\nfunction loadRemoteModule(_x10, _x11) {\n  return _loadRemoteModule.apply(this, arguments);\n}\nfunction _loadRemoteModule() {\n  _loadRemoteModule = _asyncToGenerator(function* (optionsOrRemoteName, exposedModule) {\n    let loadRemoteEntryOptions;\n    let key;\n    let remoteEntry;\n    let options;\n    if (typeof optionsOrRemoteName === 'string') {\n      options = {\n        type: 'manifest',\n        remoteName: optionsOrRemoteName,\n        exposedModule: exposedModule\n      };\n    } else {\n      options = optionsOrRemoteName;\n    }\n    // To support legacy API (< ng 13)\n    if (!options.type) {\n      const hasManifest = Object.keys(config).length > 0;\n      options.type = hasManifest ? 'manifest' : 'script';\n    }\n    if (options.type === 'manifest') {\n      const manifestEntry = config[options.remoteName];\n      if (!manifestEntry) {\n        throw new Error('Manifest does not contain ' + options.remoteName);\n      }\n      options = {\n        type: manifestEntry.type,\n        exposedModule: options.exposedModule,\n        remoteEntry: manifestEntry.remoteEntry,\n        remoteName: manifestEntry.type === 'script' ? options.remoteName : undefined\n      };\n      remoteEntry = manifestEntry.remoteEntry;\n    } else {\n      remoteEntry = options.remoteEntry;\n    }\n    if (options.type === 'script') {\n      loadRemoteEntryOptions = {\n        type: 'script',\n        remoteEntry: options.remoteEntry,\n        remoteName: options.remoteName\n      };\n      key = options.remoteName;\n    } else if (options.type === 'module') {\n      loadRemoteEntryOptions = {\n        type: 'module',\n        remoteEntry: options.remoteEntry\n      };\n      key = options.remoteEntry;\n    }\n    if (remoteEntry) {\n      yield loadRemoteEntry(loadRemoteEntryOptions);\n    }\n    return yield lookupExposedModule(key, options.exposedModule);\n  });\n  return _loadRemoteModule.apply(this, arguments);\n}\nfunction setManifest(_x12) {\n  return _setManifest.apply(this, arguments);\n}\nfunction _setManifest() {\n  _setManifest = _asyncToGenerator(function* (manifest, skipRemoteEntries = false) {\n    config = parseConfig(manifest);\n    if (!skipRemoteEntries) {\n      yield loadRemoteEntries();\n    }\n  });\n  return _setManifest.apply(this, arguments);\n}\nfunction getManifest() {\n  return config;\n}\nfunction initFederation(_x13) {\n  return _initFederation.apply(this, arguments);\n}\nfunction _initFederation() {\n  _initFederation = _asyncToGenerator(function* (manifest, skipRemoteEntries = false) {\n    if (typeof manifest === 'string') {\n      return loadManifest(manifest, skipRemoteEntries);\n    } else {\n      return setManifest(manifest, skipRemoteEntries);\n    }\n  });\n  return _initFederation.apply(this, arguments);\n}\nfunction loadManifest(_x14) {\n  return _loadManifest.apply(this, arguments);\n}\nfunction _loadManifest() {\n  _loadManifest = _asyncToGenerator(function* (configFile, skipRemoteEntries = false) {\n    const result = yield fetch(configFile);\n    if (!result.ok) {\n      throw Error('could not load configFile: ' + configFile);\n    }\n    config = parseConfig(yield result.json());\n    if (!skipRemoteEntries) {\n      yield loadRemoteEntries();\n    }\n  });\n  return _loadManifest.apply(this, arguments);\n}\nfunction parseConfig(config) {\n  const result = {};\n  for (const key in config) {\n    const value = config[key];\n    let entry;\n    if (typeof value === 'string') {\n      entry = {\n        remoteEntry: value,\n        type: 'module'\n      };\n    } else {\n      entry = {\n        ...value,\n        type: value.type || 'module'\n      };\n    }\n    result[key] = entry;\n  }\n  return result;\n}\nfunction loadRemoteEntries() {\n  return _loadRemoteEntries.apply(this, arguments);\n}\n/**\r\n * Generated bundle index. Do not edit.\r\n */\nfunction _loadRemoteEntries() {\n  _loadRemoteEntries = _asyncToGenerator(function* () {\n    const promises = [];\n    for (const key in config) {\n      const entry = config[key];\n      if (entry.type === 'module') {\n        promises.push(loadRemoteEntry({\n          type: 'module',\n          remoteEntry: entry.remoteEntry\n        }));\n      } else {\n        promises.push(loadRemoteEntry({\n          type: 'script',\n          remoteEntry: entry.remoteEntry,\n          remoteName: key\n        }));\n      }\n    }\n    yield Promise.all(promises);\n  });\n  return _loadRemoteEntries.apply(this, arguments);\n}\nexport { getManifest, initFederation, loadManifest, loadRemoteEntry, loadRemoteModule, setManifest };\n//# sourceMappingURL=angular-architects-module-federation-runtime.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}